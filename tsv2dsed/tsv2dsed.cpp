#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <string>

using namespace std;

const char* arg0 = NULL;
int min_conf = 0;
int page_offset = 0;

bool mygets(FILE* f, string& s) {
	s.clear();
	for (;;) {
		char c;
		if (fread(&c, 1, 1, f) == 0) {
			return s.empty() ? false : true;
		}
		if (c == '\r') continue;
		if (c == '\n') return true;
		s.push_back(c);
	}
}

struct TSVLine {
	int level; //0=invalid 1=page 2=block 3=par 4=line 5=word
	int page_num, block_num, par_num, line_num, word_num;
	int left, top, width, height;
	int conf;
	string text; //this is already escaped
};

class TSV {
public:
	TSV() : fin(NULL), _inputfile(NULL), lineno(0) {}
	~TSV() {
		if (fin) fclose(fin);
	}
	bool open(const char* inputfile) {
		if (fin) fclose(fin);

		_inputfile = inputfile;
		lineno = 1;

		if ((fin = fopen(inputfile, "rb")) == NULL) {
			printf("Error: failed to open input file '%s'\n", inputfile);
			return false;
		}

		//read the first line
		string s;
		mygets(fin, s);
		if (s != "level\tpage_num\tblock_num\tpar_num\tline_num\tword_num\tleft\ttop\twidth\theight\tconf\ttext") {
			printf("Warning: the first line in '%s' is unrecognized. The conversion may fail.\n", inputfile);
		}

		return true;
	}
	void close() {
		if (fin) fclose(fin);
		fin = NULL;
	}
	bool readtsvline(TSVLine& line) {
		string s;
		if (!mygets(fin, s)) return false;
		lineno++;

		line.text.clear();
		for (int i = 0, tabcount = 0, m = s.size(); i < m; i++) {
			char c = s[i];
			if (c == '\t') tabcount++;
			else if (tabcount == 11) {
				// escape char
				switch (c) {
				case '\"':
				case '\\':
					line.text.push_back('\\');
					line.text.push_back(c);
					break;
				default:
					if (c >= 32 && c <= 126) {
						line.text.push_back(c);
					} else {
						int i = (int)(unsigned char)c;
						line.text.push_back('\\');
						line.text.push_back('0' + ((i >> 6) & 7));
						line.text.push_back('0' + ((i >> 3) & 7));
						line.text.push_back('0' + ((i >> 0) & 7));
					}
					break;
				}
			}
		}

		if (sscanf(s.c_str(), "%d %d %d %d %d %d %d %d %d %d %d", &line.level,
			&line.page_num, &line.block_num, &line.par_num, &line.line_num, &line.word_num,
			&line.left, &line.top, &line.width, &line.height,
			&line.conf) != 11)
		{
			line.level = 0;
			printf("Warning: line %d in '%s' is unrecognized.\n", lineno, _inputfile);
			return true;
		}

		if (line.level < 1 || line.level > 5) {
			line.level = 0;
			printf("Warning: 'level' at line %d in '%s' is unrecognized.\n", lineno, _inputfile);
			return true;
		}

		if (line.level == 5 && line.conf < min_conf) {
			line.level = 0;
		}

		return true;
	}
private:
	FILE* fin;
	const char* _inputfile;
public:
	int lineno;
};

class TSV2DSED {
public:
	TSV2DSED() : fout(NULL) {}
	void tsv2dsed(const char* inputfile){
		TSV tsv;

		if (fout == NULL || !tsv.open(inputfile)) return;

		fprintf(fout, "# -------------------------\n"
			"# generated by tsv2dsed\n"
			"# source: %s\n", inputfile);

		current_page.page_num = 0;
		current_line.page_num = 0;
		current_line.line_num = 0;

		TSVLine line;

		while (tsv.readtsvline(line)) {
			switch (line.level) {
			case 1: //page
				endofpage();
				fprintf(fout, "# -------------------------\n"
					"select %d\n"
					"set-txt\n"
					"(page 0 0 %d %d\n",
					line.page_num + page_offset, line.width, line.height);
				current_page = line;
				break;
			case 4: //line
				endofline();
				fprintf(fout, " (line %d %d %d %d\n",
					line.left, current_page.height - (line.top + line.height),
					line.left + line.width, current_page.height - line.top);
				current_line = line;
				break;
			case 5: //word
				if (line.page_num == current_line.page_num &&
					line.block_num == current_line.block_num &&
					line.par_num == current_line.par_num &&
					line.line_num == current_line.line_num)
				{
					fprintf(fout, " ");
				} else {
					printf("Warning: an orphan word at line %d of '%s' is unrecognized.\n", tsv.lineno, inputfile);
				}
				fprintf(fout, " (word %d %d %d %d \"%s\")\n",
					line.left, current_page.height - (line.top + line.height),
					line.left + line.width, current_page.height - line.top,
					line.text.c_str());
				break;
			}
		}

		endofpage();

		tsv.close();
	}
	void tsv2dsed(const char* inputfile, const char* outputfile){
		if ((fout = fopen(outputfile, "wb")) == NULL) {
			printf("Error: failed to open output file '%s'\n", outputfile);
			return;
		}

		tsv2dsed(inputfile);

		fclose(fout);
		fout = NULL;
	}
private:
	void endofline() {
		if (current_line.page_num > 0 && current_line.line_num > 0) {
			fprintf(fout, " )\n");
			current_line.page_num = 0;
			current_line.line_num = 0;
		}
	}
	void endofpage() {
		endofline();
		if (current_page.page_num > 0) {
			fprintf(fout, ")\n\n.\n");
			current_page.page_num = 0;
		}
	}
public:
	FILE* fout;
private:
	TSVLine current_page;
	TSVLine current_line;
};

void help() {
	printf(
		"Converts *.tsv (output of Tesseract) to *.dsed (input of djvused)\n"
		"\n"
		"Usage: %s [options] inputfile outputfile ...\n"
		"   or: %s -o outputfile [options] inputfile ...\n"
		"\n"
		"Options are:\n"
		"  -h, --help        print this help and exit\n"
		"  -c number         set minimum confidence level (default 0)\n"
		"  -p number         set page number of first page (default 1)\n"
		"  -o outputfile     set output file (for multiple input files)\n"
		"\n"
		"Limitations:\n"
		"  Currently only exports page, line and word.\n"
		, arg0, arg0);
	exit(1);
}

int main(int argc, char** argv) {
	arg0 = argv[0];

	if (argc < 3) help();

	const char *inputfile = NULL;
	FILE* fout = NULL;

	for (int i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			if (strcmp(argv[i], "-c") == 0) {
				i++;
				if (i > argc) help();
				min_conf = atoi(argv[i]);
				if (min_conf < 0) min_conf = 0;
				if (min_conf > 100) min_conf = 100;
			} else if (strcmp(argv[i], "-p") == 0) {
				i++;
				if (i > argc) help();
				page_offset = atoi(argv[i]) - 1;
			} else if (strcmp(argv[i], "-o") == 0) {
				i++;
				if (i > argc) help();				
				if (fout) fclose(fout);
				if ((fout = fopen(argv[i], "wb")) == NULL) {
					printf("Error: failed to open output file '%s'\n", argv[i]);
					return 1;
				}
			} else {
				help();
			}
		} else {
			if (fout) {
				TSV2DSED tsv2dsed;
				tsv2dsed.fout = fout;
				tsv2dsed.tsv2dsed(argv[i]);
			} else if (inputfile == NULL) {
				inputfile = argv[i];
			} else {
				TSV2DSED tsv2dsed;
				tsv2dsed.tsv2dsed(inputfile, argv[i]);
				inputfile = NULL;
			}
		}
	}

	if (fout) fclose(fout);

	return 0;
}